{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Incident Bot Documentation","text":"<p>Incident Bot is an open-source incident management framework.</p> <p>The core feature is a ChatOps bot to allow your teams to easily and effectively identify and manage technical incidents impacting your cloud infrastructure, your products, or your customers' ability to use your applications and services.</p>"},{"location":"#core-technologies","title":"Core Technologies","text":"<ul> <li>Pydantic is used to handle data validation and type safety across the platform.</li> <li>Pydantic Settings is used to handle application configuration settings.</li> <li>SQLModel is used to handle the relationship between application objects and backend databases.</li> <li>FastAPI is used to handle the API.</li> </ul>"},{"location":"#features-at-a-glance","title":"Features at a Glance","text":"<ul> <li>Create a channel in Slack to gather resources and handle incidents.</li> <li>Digest channel to keep the rest of the organization up to date with incidents at all time.</li> <li>Define your own roles, severities, and statuses, or use ones configured right out of the box.</li> <li>Keep stakeholders updated using dynamic updates.</li> <li>Craft a postmortem document using an integration with Confluence that allows you to use your own templates.</li> <li>Create issues in Jira directly from incident channels.</li> <li>Page teams in PagerDuty or OpsGenie.</li> <li>Manage Statuspage incidents directly from incident channels.</li> <li>Create Zoom meetings for each incident to keep communications organized.</li> <li>A web interface with advanced features and administrative functionality.</li> </ul>"},{"location":"#integrations","title":"Integrations","text":"<p>For more information on integrations, check out the integrations documentation.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<ul> <li>Create a Slack app for this application.</li> <li>Select <code>from an app manifest</code> and copy <code>manifest.yaml</code> out of this repository and paste it in to automatically configure the app.</li> <li>You'll need the app token, bot token, and user token for your application and provide those as <code>SLACK_APP_TOKEN</code>, <code>SLACK_BOT_TOKEN</code>, and <code>SLACK_USER_TOKEN</code> - these can be found within the app's configuration page in Slack.</li> <li>You'll need a Postgres instance to connect to.</li> <li>Create a channel to serve as your incident \"digest\" channel - something like <code>#incidents</code>.</li> <li>Configure the app using <code>config.yaml</code> and deploy it to Kubernetes, Docker, or whichever platform you choose. Check out the installation guide for more details.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v2014-2024-10-10","title":"v2.0.14 (2024-10-10)","text":"<ul> <li>Builds an arm64 version of the util image.</li> <li>Adds tests for image suffixes to chart.</li> <li>Minor version bumps for Poetry-managed packages.</li> </ul>"},{"location":"changelog/#v2013-2024-10-05","title":"v2.0.13 (2024-10-05)","text":"<ul> <li>Fix bug with maintenance window management.</li> </ul>"},{"location":"changelog/#v2012-2024-10-05","title":"v2.0.12 (2024-10-05)","text":"<ul> <li>Fix bugs with Statuspage integration.</li> <li>This release requires a database migration - please plan accordingly. This is handled by the chart if using its init features.</li> </ul>"},{"location":"changelog/#v209-2024-09-30","title":"v2.0.9 (2024-09-30)","text":"<ul> <li>Allow disabling the API docs endpoint.</li> <li>Updates to docs for web interface.</li> </ul>"},{"location":"changelog/#v208-2024-09-30","title":"v2.0.8 (2024-09-30)","text":"<ul> <li>Corrections in documentation for web interface usage.</li> <li>Add some packages required for docs development.</li> </ul>"},{"location":"changelog/#v207-2024-09-30","title":"v2.0.7 (2024-09-30)","text":"<ul> <li>Fixes bug where <code>postmortem_link</code> variable didn't work if integration was disabled.</li> <li>Fixes potential bugs where <code>this</code> command prompts resulted in errors due to responses from Slack.</li> <li>Bumps a few packages.</li> </ul>"},{"location":"changelog/#v206-2024-09-26","title":"v2.0.6 (2024-09-26)","text":"<ul> <li>Fixes bug where PagerDuty information would not store in the database properly.</li> <li>Fixes bug where trying to create more than one PagerDuty incident per bot incident failed.</li> <li>Fixes bug where matching a bot incident when trying to create a PagerDuty incident failed.</li> <li>Fixes bug where creating a PagerDuty incident failed because the column that used to store incidents has been removed.</li> <li>PagerDuty incidents now create records properly.</li> <li>The message when a page is issue now contains a link to the incident it creates.</li> </ul>"},{"location":"changelog/#v205-2024-09-24","title":"v2.0.5 (2024-09-24)","text":"<ul> <li>Fixes bug where <code>postmortem_link</code> was no longer a valid argument for generating a digest message update.</li> <li>Adds link to postmortem in a digest message if one is passed in when the method is called.</li> <li>Adds retry logic to all Slack API requests to avoid failures based on data not populating.</li> <li>Fixes bug where a user's real name being unavailable for parsing would cause other things to fail.</li> </ul>"},{"location":"changelog/#v204-2024-09-23","title":"v2.0.4 (2024-09-23)","text":"<ul> <li>Fixes bug where the incident list functionality did not work via command or within app home in Slack.</li> <li>Fixes incorrect content in some Helm templates.</li> <li>Adds value to Helm chart to set database password if using built-in database.</li> <li>Fixes bug in Helm chart where the <code>ConfigMap</code> data to populate <code>config.yaml</code> did not mount anything, resulting in the app always using default values.</li> <li>Fixes some spelling mistakes in the documentation.</li> <li>Adds clarity to documentation around database migrations.</li> <li>Fixes bug where the <code>enterprise</code> value in Slack responses was assumed to always be <code>str</code>, but can actually be <code>dict</code>.</li> <li>Cleans up some minor errors around the pager modal.</li> </ul>"},{"location":"changelog/#v203-2024-09-20","title":"v2.0.3 (2024-09-20)","text":"<ul> <li>Adds unit testing to Helm chart.</li> <li>Adds better readme for Helm chart.</li> <li>Minor chart cleanup and fixes.</li> </ul>"},{"location":"changelog/#v201-2024-09-20","title":"v2.0.1 (2024-09-20)","text":"<ul> <li>Add init containers to Helm chart to handle database migrations.</li> <li>Add Dockerfile to build utility image for use with migrations and other tasks.</li> <li>Clarify in documentation any steps regarding database migrations.</li> <li>Add jobs to CircleCI build to test util and docs builds and build util image.</li> <li>Move all Dockerfiles to root and fix references.</li> <li>Update .gitignore file.</li> <li>Fix versioning script.</li> </ul>"},{"location":"changelog/#v200-2024-09-19","title":"v2.0.0 (2024-09-19)","text":"<ul> <li>Poetry has been adopted for Python package management, replacing the legacy pattern.</li> <li>Pydantic is now used for both type-safety and convenience as well as configuration management.</li> <li>SQLModel is now used to manage database models, extending the usefulness of Pydantic.</li> <li>The database schema has changed entirely. It is recommended to start fresh if you have an existing deployment.</li> <li>FastAPI has replaced Flask as the API framework, further extending the usefulness of Pydantic.</li> <li>Configuration has been flattened and simplified. There is now no hard requirement to provide a <code>config.yaml</code> file if accepting all defaults.</li> <li>Statuses are now fully customizable and there are no hard dependencies on specific ones. You have the ability to decide initial and final statuses.</li> <li>There is now a feature to create and manage maintenance windows to advertise scheduled maintenance. This feature is new and will have more functionality added over time.</li> <li>There is now an option to create an additional \"comms\" channel alongside incident channels to separate critical communications. This is entirely optional.</li> <li>All message formatting has been rebuilt to be cleaner and easier to look at.</li> <li>Reacji to pin content is now customizable.</li> <li>Reacting with reacji to messages to open incidents has been removed.</li> <li>Migrations are now required for all database operations. A base Alembic migration is provided and must be run prior to first startup.</li> <li>All use of shortcuts has been removed and replaced with slash commands. No more searching for specific commands.</li> <li>All interaction is handled using ephemeral messages to reduce clutter in public channels.</li> <li>Timestamp issues have been fixed by removing storing string timestamps in the database as strings and handling this via native database time columns.</li> <li>Introduces patterns to adopt more providers than Slack in future releases.</li> <li>Logs can now be pretty printed or JSON.</li> <li>There are new jobs for communications reminders and role watcher. These jobs will send messages to an incident channel to remind participants to send out regular updates and to claim unclaimed roles. Either can be disabled or dismissed.</li> <li>Postmortem generation now requires a Confluence template. The bot will no longer generate an entire page layout for you. There are template strings that can be placed in a template to inject values from the incident, leaving the rest up to you.</li> <li>The UI has been replaced with a new framework largely inspired by FastAPI's fullstack example.</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>Application configuration is handled using pydantic-settings.</p> <p>The bot is configured to look for environment variebles from the sys environment and a <code>.env</code> file (dotenv) in that order.</p> <p>All other configuration options are handled by creating a <code>config.yaml</code> file. Almost all settings have default values, so you can run the application without creating a <code>config.yaml</code> file, but if you wish to enable integrations or change various settings, you'll want to create one.</p> <p>Please review the integrations documentation for additional information on enabling and configuring integrations.</p>"},{"location":"configuration/#configurable-parameters","title":"Configurable Parameters","text":""},{"location":"configuration/#api","title":"API","text":"<p>Additional API routes are disabled by default. This flag only needs to be set to <code>true</code> if using the web interface.</p> <p>Note that the API exposes a health check route.</p> <p>Note</p> <p>The web interface is optional and is not required to use the application.</p> <pre><code>api:\n  enabled: true\n</code></pre> <p>With the API enabled, routes will be made available via <code>/api/v1</code>.</p> <p>Warning</p> <p>API routes are only meant to serve the web interface. As such, they are secured using JWT and will not work without first running through the setup guide for the web interface.</p> <p>Warning</p> <p>The default username and password for the web interface are set to <code>admin@example.com</code>:<code>changethis</code>. It is strongly recommended you change these variables before exposing the API.</p> <p>Set the environment variables <code>FIRST_SUPERUSER</code> and <code>FIRST_SUPERUSER_PASSWORD</code> to unique values before running the application the first time.</p> <pre><code># incidentbot/configuration/settings.py\nFIRST_SUPERUSER: str = \"admin@example.com\"\nFIRST_SUPERUSER_PASSWORD: str = \"changethis\"\n</code></pre>"},{"location":"configuration/#documentation-endpoints","title":"Documentation Endpoints","text":"<p>All endpoints related to documentation for the API are disabled by default. You don't have to provide these values in the settings configuration if you don't wish to override them.</p> <p>To enable them, use the following settings:</p> <pre><code># Set any of these to true to enable them.\napi:\n  enable_docs_endpoint: false # /docs\n  enable_openapi_endpoint: false # /openapi.json\n  enable_redoc_endpoint: false # /redoc\n</code></pre> <p>It is recommended to keep these disabled when the API is exposed to the general public.</p>"},{"location":"configuration/#digest-channel","title":"Digest Channel","text":"<p>The digest channel is where updates are sent regarding all incidents managed by the bot. The channel is <code>#incidents</code> by default.</p> <p>To change it, set the following value in <code>config.yaml</code>:</p> <pre><code># This is the default value.\ndigest_channel: incidents\n</code></pre>"},{"location":"configuration/#pinned-images","title":"Pinned Images","text":"<p>Pinning images to incident timelines is enabled by default.</p> <p>To disable this behavior, set the following value in <code>config.yaml</code>:</p> <pre><code>enable_pinned_images: false\n</code></pre> <p>Note</p> <p>You may not be able to pin images on a free/trial plan. The API method that it requires, <code>files.sharedPublicURL</code>, typically won't work.</p> <p>That being said, it has worked fine in the past despite the error that will show in the logs.</p>"},{"location":"configuration/#initial-communications-reminders","title":"Initial Communications Reminders","text":"<p>The bot will watch all incidents that are created and will send notifications to the channel to remind participants to send out updates and claim roles if they remain unclaimed.</p> <p>To change the amount of time the bot waits before sending these notifications, set the following values in <code>config.yaml</code>:</p> <pre><code># These are the default values.\ninitial_comms_reminder_minutes: 30\ninitial_role_watcher_minutes: 10\n</code></pre>"},{"location":"configuration/#links","title":"Links","text":"<p>foo do these even get used?</p>"},{"location":"configuration/#maintenance-windows","title":"Maintenance Windows","text":"<p>The bot has a feature that will send out notifications for scheduled maintenance. This feature is disabled by default.</p> <p>To enabled this feature, set the following value in <code>config.yaml</code>:</p> <pre><code>maintenance_windows:\n  components:\n    - API\n    - Auth\n    - Databases\n    - Website\n</code></pre> <p>By setting a list of components that will show up as components related to a maintenance window, the feature will be enabled.</p> <p>By default, statuses for maintenance windows are <code>Scheduled</code>, <code>In Progress</code>, <code>Complete</code>. If you wish to override these values, you can add the following block to the settings:</p> <pre><code>maintenance_windows:\n  statuses:\n    - Scheduled\n    - In Progress\n    - Complete\n</code></pre> <p>Note that statuses should be stated in order of start to finish. The first status should be the initial status, etc.</p>"},{"location":"configuration/#options","title":"Options","text":"<p>There is an <code>options</code> section that holds several settings.</p> <p>To change any of these values, set the following values in <code>config.yaml</code>:</p> <pre><code>options:\n  additional_welcome_messages:\n    # Any additional messages to add to a new incident when it is opened.\n    - message: \"Welcome to the incident. Please be sure to...\"\n      pin: true # false by default\n  auto_invite_groups:\n    - name: str\n      # Only if PagerDuty integration is enabled\n      # Create a page when these groups are invited\n      pagerduty_escalation_policy: some-policy\n      pagerduty_escalation_priority: high\n      severities: sev1,sev2\n      # severities: all\n  # This is the default value. This is what all incident channels are prefixed with.\n  channel_name_prefix: inc\n  # There is no default value for this. If one is set, this URL will be used for the meeting advertised with each incident.\n  # Will not be used if using automatic Zoom meeting generation.\n  meeting_link: None\n  # If true, pin the meeting link to the incident channel upon creation.\n  pin_meeting_link_to_channel: false\n  # This limits the amount of incidents shown on the summary on the app home page.\n  # It is not recommended to raise this value very high due to Slack limitations on how many blocks can appear in a message.\n  # This is the default value.\n  show_most_recent_incidents_app_home_limit: 5\n  # Application timezone.\n  # This is the default value.\n  timezone: UTC\n</code></pre>"},{"location":"configuration/#platform","title":"Platform","text":"<p>Right now, the only valid value for the <code>platform</code> field is <code>slack</code>.</p>"},{"location":"configuration/#roles","title":"Roles","text":"<p>You can use the default incident management roles or define your own.</p> <p>Roles are configured using the following format. The \"commander,\" or \"lead\" role, should be marked with <code>is_lead</code>.</p> <p>Note</p> <p>You do not need to provide the default values displayed below if you wish to use the default values. This is provided as an example of how to configure custom values.</p> <pre><code>roles:\n  incident_commander:\n    description: \"The Incident Commander is the decision maker during a major incident, delegating tasks and listening to input from subject matter experts in order to bring the incident to resolution. They become the highest ranking individual on any major incident call, regardless of their day-to-day rank. Their decisions made as commander are final.\\n\\nYour job as an Incident Commander is to listen to the call and to watch the incident Slack room in order to provide clear coordination, recruiting others to gather context and details. You should not be performing any actions or remediations, checking graphs, or investigating logs. Those tasks should be delegated.\\n\\nAn IC should also be considering next steps and backup plans at every opportunity, in an effort to avoid getting stuck without any clear options to proceed and to keep things moving towards resolution.\\n\\nMore information: https://response.pagerduty.com/training/incident_commander/\"\n    is_lead: true\n  scribe:\n    description: \"The purpose of the Scribe is to maintain a timeline of key events during an incident, documenting actions, and keeping track of any follow-up items that will need to be addressed.\\n\\nMore information: https://response.pagerduty.com/training/scribe/\"\n  subject_matter_expert:\n    description: \"A Subject Matter Expert (SME) is a domain expert or designated owner of a component or service that is part of the software stack. These are critical members of the incident response process that play pivotal roles in identifying and resolving individual components of impacted ecosystems.\\n\\nMore information: https://response.pagerduty.com/training/subject_matter_expert/\"\n  communications_liaison:\n    description: \"The purpose of the Communications Liaison is to be the primary individual in charge of notifying our customers of the current conditions, and informing the Incident Commander of any relevant feedback from customers as the incident progresses.\\n\\nIt's important for the rest of the command staff to be able to focus on the problem at hand, rather than worrying about crafting messages to customers.\\nYour job as Communications Liaison is to listen to the call, watch the incident Slack room, and track incoming customer support requests, keeping track of what's going on and how far the incident is progressing (still investigating vs close to resolution).\\n\\nThe Incident Commander will instruct you to notify customers of the incident and keep them updated at various points throughout the call. You will be required to craft the message, gain approval from the IC, and then disseminate that message to customers.\\n\\nMore information: https://response.pagerduty.com/training/customer_liaison/\"\n</code></pre>"},{"location":"configuration/#severities","title":"Severities","text":"<p>You can use the default incident management severities or define your own.</p> <p>Severities are configured using the following format.</p> <p>Note</p> <p>You do not need to provide the default values displayed below if you wish to use the default values. This is provided as an example of how to configure custom values.</p> <pre><code>severities:\n  sev1: \"This signifies a critical production scenario that impacts most or all users with a major impact on SLAs. This is an all-hands-on-deck scenario that requires swift action to restore operation. Customers must be notified.\"\n  sev2: \"This signifies a significant production degradation scenario impacting a large portion of users.\"\n  sev3: \"This signifies a minor production scenario that may or may not result in degradation. This situation is worth coordination to resolve quickly but does not indicate a critical loss of service for users.\"\n  sev4: \"This signifies an ongoing investigation. This incident has not been promoted to SEV3 yet, indicating there may be little to no impact, but the situation warrants a closer look. This is diagnostic in nature. This is the default setting for a new incident.\"\n</code></pre>"},{"location":"configuration/#statuses","title":"Statuses","text":"<p>You can use the default incident management statuses or define your own.</p> <p>Statuses are configured using the following format.</p> <p>Note</p> <p>You do not need to provide the default values displayed below if you wish to use the default values. This is provided as an example of how to configure custom values.</p> <pre><code>statuses:\n  investigating:\n    initial: true\n  identified: {}\n  monitoring: {}\n  resolved:\n    final: true\n</code></pre> <p>It is important to mark a status as <code>initial</code> and a status as <code>final</code> either way. This tells the bot the starting and finishing value for incident statuses.</p>"},{"location":"configuration/#slash-command","title":"Slash Command","text":"<p>The bot's default slash command is <code>/incidentbot</code>. If you wish to override it, you ca</p> <p>To change this value, set the following value in <code>config.yaml</code>:</p> <pre><code># This is the default value.\nroot_slash_command: '/incidentbot'\n</code></pre> <p>Note</p> <p>If you change this value, be sure to update the manifest to match.</p>"},{"location":"configuration/#updates","title":"Updates","text":"<p>When using the \"provide incident update\" functionality, default behavior is to add any updates for an incident as comments under the original thread in the digest channel. If you wish to send all updates to the digest channel directly instead, set the following value in <code>config.yaml</code>:</p> <pre><code>options:\n  updates_in_threads: true\n</code></pre>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#why-cant-the-bot-delete-channels","title":"Why can't the bot delete channels?","text":"<p>The Slack API limits that ability to Enterprise Grid workspaces. Thus far, it has not been tested in any of those.</p>"},{"location":"faq/#why-do-i-get-a-message-from-the-bot-stating-a-public-link-was-created-to-my-file-when-an-image-i-uploaded-to-an-incident-channel-was-pinned","title":"Why do I get a message from the bot stating a public link was created to my file when an image I uploaded to an incident channel was pinned?","text":"<p>This is because a public link has to be created temporarily in order to fetch the image content from the Slack API. That public access is removed immediately afterward. This is normal and expected behavior.</p>"},{"location":"faq/#how-do-i-handle-database-migrations","title":"How do I handle database migrations?","text":"<p>Locally, you can use <code>make run-migrations</code>. If using the Helm chart, there's an option to run migrations an init container.</p> <p>See the documentation for migrations here.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#communications-reminder-role-watcher","title":"Communications Reminder &amp; Role Watcher","text":"<p>For all newly created incidents, the bot will wait for a configurable amount of time, <code>30 minutes</code> by default, before sending a reminder about keeping others up to date regarding the incident:</p> <p></p> <p>You can dismiss this message or cancel it.</p> <p>The bot will also send out a reminder if roles have remained unclaimed:</p> <p></p>"},{"location":"features/#maintenance-windows","title":"Maintenance Windows","text":"<p>Maintenance windows are an optional feature. If enabled, the bot will allow the creation of scheduled maintenance windows to describe things that a team will be doing as part of scheduled operations. These notifications will be sent to a list of channels automatically during updates.</p> <p>This is useful if you don't have a formal system in place for handling maintenance window notifications.</p> <p>If enabled, there's a button on the bot's home screen that prompts for creating a maintenance window. If you choose this option, you're presented with the following modal:</p> <p> </p> <p>Once submitted, the bot will let you know the maintenance window was created.</p> <p>From here, you can view any maintenance windows that are not marked as <code>Complete</code> from the app home screen:</p> <p></p> <p>Or you can use the bot's slash command <code>maintenance</code> subcommand to work with maintenance windows by running <code>/incidentbot maintenance</code>:</p> <p> </p> <p>When you're ready to change a maintenance window's status, click on <code>Set Status</code> in either location:</p> <p> </p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Create a Slack app for this application. You can name it whatever you'd like.</li> <li>Select <code>from an app manifest</code> and copy <code>manifest.yaml</code> out of this repository and paste it in to automatically configure the app and its required settings. Be sure to override any customizable settings like name, etc.</li> <li>You'll need the app token, bot token, and user token for your application and provide those as the <code>SLACK_APP_TOKEN</code>, <code>SLACK_BOT_TOKEN</code>, and <code>SLACK_USER_TOKEN</code> environment variables - these can be found within the app's configuration page in Slack. For more information on Slack tokens, see the documentation here.</li> <li>You'll need a Postgres instance to connect to. If trying the bot out using Docker Compose or Helm, there are options to run a database alongside the app.</li> <li>Configure and deploy the application using one of the methods described below, or however you choose. (There's a Docker image available.)</li> </ul>"},{"location":"installation/#database-migrations","title":"Database Migrations","text":"<p>The application does not handle database migrations automatically. This means that database migrations should be run using a bootstrap or init process.</p> <p>If you use the official Helm chart, two init containers are created - one to wait for the database to become available, and another to run the migrations.</p> <p>This feature is enabled by default:</p> <pre><code># values.yaml\ninit:\n  enabled: true\n  command: ['/bin/sh']\n  args: ['-c', 'alembic upgrade head']\n  image:\n    tag:\n</code></pre> <p>We provide an image called <code>eb129/incidentbot:util</code> that is used for this step. You can provide your own image using the <code>image</code> and/or <code>tag</code> options shown above.</p> <p>Warning</p> <p>If you choose to use your own image, be sure it conforms to the requirements of the application.</p> <p>Note</p> <p>If you do not use the Helm chart and install using other methods, take note of how this is done using Docker Compose:</p> <pre><code>migrations:\n  build:\n    context: .\n    dockerfile: Dockerfile.util\n  depends_on:\n    db:\n      condition: service_healthy\n  command: ['sh', '-c', 'alembic upgrade head']\n  environment:\n    IS_MIGRATION: true\n    POSTGRES_HOST: db\n    POSTGRES_DB: incident_bot\n    POSTGRES_USER: incident_bot\n    POSTGRES_PASSWORD: somepassword\n    POSTGRES_PORT: 5432\n  volumes:\n    # Wherever the config file lives, root by default\n    - ./config.yaml:/app/config.yaml\n  networks:\n    - inc_bot_network\n</code></pre> <p>In the end, you simply need a process that runs <code>alembic upgrade head</code> before the application starts.</p> <p>Note</p> <p>If using the Helm chart and setting <code>envFromSecret</code>, those variables will be passed to the init containers.</p>"},{"location":"installation/#required-variables","title":"Required Variables","text":"<p>These variables are required for all installation methods:</p> <ul> <li><code>POSTGRES_HOST</code> - the hostname of the database.</li> <li><code>POSTGRES_DB</code> - database name to use.</li> <li><code>POSTGRES_USER</code> - database user to use.</li> <li><code>POSTGRES_PASSWORD</code> - password for the user.</li> <li><code>POSTGRES_PORT</code> - the port to use when connecting to the database.</li> <li><code>SLACK_APP_TOKEN</code> - the app-level token for enabling websocket communication. Found under your Slack app's <code>Basic Information</code> tab in the <code>App-Level Tokens</code> section.</li> <li><code>SLACK_BOT_TOKEN</code> - the API token to be used by your bot once it is deployed to your workspace for <code>bot</code>-scoped pemissions. Found under your Slack app's <code>OAuth &amp; Permissions</code> tab.</li> <li><code>SLACK_USER_TOKEN</code> - the API token to be used by your bot for <code>user</code>-scoped permissions. Found under your Slack app's <code>OAuth &amp; Permissions</code> tab.</li> </ul>"},{"location":"installation/#architecture-support","title":"Architecture Support","text":"<p>Images are built for both <code>amd64</code> and <code>arm64</code>.</p> <p>To adjust which one is used with Helm:</p> <pre><code># values.yaml\nimage:\n  suffix: arm64\n</code></pre>"},{"location":"installation/#kubernetes","title":"Kubernetes","text":""},{"location":"installation/#helm","title":"Helm","text":"<p>You can get started quickly by using the Helm chart:</p> <pre><code>helm repo add incidentbot https://charts.incidentbot.io\nhelm repo update\n</code></pre> <p>Sensitive data should come from Kubernetes <code>Secret</code> objects. </p> <p>Warning</p> <p>Secrets management is outside of the scope of this application. Choose the solution that works best for you. Any solution that renders a Kubernetes <code>Secret</code> that contains the key/value data for your sensitive application information will work.</p> <p>One method is to used something like sealed-secrets.</p> <p>If using <code>sealed-secrets</code>, you could put your sensitive environment variables in a <code>.env</code> file and create the <code>Secret</code> using the following command:</p> <pre><code>kubectl create secret generic incidentbot-secret --from-env-file=.env --dry-run='client' -ojson --namespace incidentbot &gt;incidentbot-secret.json &amp;&amp;\n  kubeseal --controller-name sealed-secrets &lt;incidentbot-secret.json &gt;incidentbot-secret-sealed.json &amp;&amp;\n  kubectl create -f incidentbot-secret-sealed.json\n</code></pre> <p>Contained with <code>.env</code>, you'd want to include the sensitive values for this application. For example:</p> <pre><code>SLACK_APP_TOKEN=xapp-1-...\nSLACK_BOT_TOKEN=...\nSLACK_USER_TOKEN=xoxp-...\n# any integration secrets\n# and so on...\n</code></pre> <p>This will create the required <code>Secret</code> in the <code>Namespace</code> <code>incidentbot</code>. You may need to create the <code>Namespace</code> if it doesn't exist.</p> <p>Create a <code>values.yaml</code> file. We'll call this one <code>incidentbot-values.yaml</code>:</p> <pre><code>envFromSecret:\n  enabled: true\n  secretName: incidentbot-secret\ningress:\n  enabled: true\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    cert-manager.io/cluster-issuer: letsencrypt-prod\n  hosts:\n    - host: incidentbot.mydomain.com\n      paths:\n        - path: /\n          pathType: ImplementationSpecific\n  tls:\n    - secretName: incidentbot-tls\n      hosts:\n        - incidentbot.mydomain.com\n</code></pre> <p>Run the following command to install the resources using the chart:</p> <pre><code>VERSION=$(helm search repo incidentbot --output=json | jq '.[0].version' | tr -d '\"')\nhelm install incidentbot/incidentbot --version $VERSION --values incidentbot-values.yaml --namespace incidentbot\n</code></pre> <p>To clean everything up:</p> <pre><code>helm uninstall incidentbot --namespace incidentbot\n</code></pre>"},{"location":"installation/#using-the-built-in-database","title":"Using the built-in database","text":"<p>There is an option for testing or demo environments to deploy a database alongside the application:</p> <pre><code># values.yaml\ndatabase:\n  enabled: true\n  password: somepassword\n</code></pre> <p>Warning</p> <p>This is not recommended for production use. You should setup a database independently and provide its credentials to the application instead.</p>"},{"location":"installation/#configuration","title":"Configuration","text":"<p>The application's <code>config.yaml</code> settings can be set using the <code>configMap</code> option:</p> <pre><code># values.yaml\nconfigMap:\n  create: true\n  data:\n    options:\n      skip_logs_for_user_agent:\n        - kube-probe\n        - ELB-HealthChecker/2.0\n      timezone: America/New_York\n    maintenance_windows:\n      components:\n        - Website\n        - API\n        - Auth\n        - Databases\n</code></pre> <p>Any data under the <code>data</code> key will be added to the <code>ConfigMap</code> and will be made available to the application.</p> <p>You are not required to provide this option if you wish to use all of the default settings.</p> <p>Consult the configuration page for details on all configurable options.</p>"},{"location":"installation/#docker-compose","title":"Docker Compose","text":"<p>A sample compose file is provided with sample variables. This is useful for running the application locally. In this scenario, the database runs as a container. This is not recommended for production usage.</p> <p>Warning</p> <p>Management of a database is outside of the scope of this application. Setup for a containerized database is provided for convenience when using Docker Compose.</p>"},{"location":"integrations/","title":"Integrations","text":"<p>Incident Bot features several integrations to help with automation at critical junctures during the incident management process.</p>"},{"location":"integrations/#atlassian","title":"Atlassian","text":"<p>The bot supports the following Atlassian products:</p> <ul> <li>Confluence</li> <li>Jira</li> <li>Opsgenie</li> <li>Statuspage</li> </ul> <p>To start with any of these integrations, you'll need an API token for your Atlassian account. The token can be created here.</p> <p>Provide the following environment variables to the bot:</p> <ul> <li><code>ATLASSIAN_API_URL</code> - The URL of the Atlassian account.</li> <li><code>ATLASSIAN_API_USERNAME</code> - Username that owns the API token.</li> <li><code>ATLASSIAN_API_TOKEN</code> - The API token.</li> </ul>"},{"location":"integrations/#confluence","title":"Confluence","text":"<p>You are required to provide a template ID for the bot to use - the bot will not create a page that is not based on a template. If you do not provide a template, the bot will not create a postmortem document.</p> <p>See the configuration section on statuses to understand how to configure a qualifying status to trigger postmortem generation.</p>"},{"location":"integrations/#using-the-confluence-integration","title":"Using the Confluence Integration","text":"<p>The bot makes the following information from each incident available for each postmortem document using injection flags:</p> <ul> <li><code>!ib-inject-components</code></li> <li><code>!ib-inject-created-at</code></li> <li><code>!ib-inject-description</code></li> <li><code>!ib-inject-duration</code></li> <li><code>!ib-inject-impact</code></li> <li><code>!ib-inject-participants</code></li> <li><code>!ib-inject-severity</code></li> <li><code>!ib-inject-updated-at</code></li> </ul> <p>To use these, simply add these flags to your template. For example - this is a fully valid template for a Confluence postmortem document:</p> <pre><code>## Description\n\n!ib-inject-description\n\n!ib-inject-severity\n\n!ib-inject-created-at\n\n## Participants\n\n!ib-inject-participants\n\n## Impact\n\n!ib-inject-impact\n\n## Components\n\n!ib-inject-components\n\n## Timeline\n\n!ib-inject-timeline\n</code></pre> <p>The bot would replace each call to an injection flag with the content for that flag. In the end, you'll have a document rendered using your template with the referenced flags replaced by actual content.</p>"},{"location":"integrations/#configurating-the-confluence-integration","title":"Configurating the Confluence Integration","text":"<p>In the application's <code>config.yaml</code>, you can set the Confluence space and parent page and Jira settings using the <code>integrations</code> section:</p> <p>Warning</p> <p>You must provide all of these values in order for the integration to work. There are no default values for integrations.</p> <pre><code>integrations:\n  atlassian:\n    confluence:\n      enabled: true\n      auto_create_postmortem: true\n      parent: Postmortems\n      space: ENGINEERING\n      template_id: 12345678\n</code></pre> <p>If the integration is properly configured, when an incident is set to its <code>final</code> status, you'll see a notification in the channel regarding the creation of a postmortem document:</p> <p></p> <p>If you've used the appropriate flags in your document, data should be populated. Here's a very basic example showing how this works:</p> <p></p> <p>Here's the incident that postmortem references for comparison:</p> <p></p>"},{"location":"integrations/#jira","title":"Jira","text":"<p>The bot can open a Jira issue when an incident is created. You can optionally create any number of additional Jira issues directly from an incident.</p>"},{"location":"integrations/#using-the-jira-integration","title":"Using the Jira Integration","text":"<p>In the <code>jira</code> section, the <code>project</code> field is required. All other fields are optional.</p> <p>If you do not provide <code>issue_types</code> or <code>priorities</code>, the bot will attempt to automatically fetch them from Jira. If this fails, you will need to provide them manually. Failure is often the result of too many items being returned from the Atlassian API and a limitation in Slack on how many items a single message can contain.</p> <p>It is recommended to provide these manually if you wish to control them more.</p>"},{"location":"integrations/#issue-types","title":"Issue Types","text":"<p>This is a list of strings. This will populate the list of selectable issue types when creating a Jira ticket. These must be valid options for issue types in your Jira environment.</p>"},{"location":"integrations/#priorities","title":"Priorities","text":"<p>This is a list of strings. This will populate the list of selectable priorities when creating a Jira ticket. These must be valid options for priorities in your Jira environment.</p>"},{"location":"integrations/#controlling-creation","title":"Controlling Creation","text":"<p>In the <code>jira</code> configuration section seen below, you can control whether or not an issue is created when an incident is started using the following options:</p> <pre><code>auto_create_issue: true\nauto_create_issue_type: Task\n</code></pre> <p>This would create a Task when an incident is opened containing the name of the incident.</p>"},{"location":"integrations/#configurating-the-jira-integration","title":"Configurating the Jira Integration","text":"<p>In the application's <code>config.yaml</code>, you can adjust <code>jira</code> settings using the <code>integrations</code> section:</p> <p>Warning</p> <p>You must provide all of these values in order for the integration to work. There are no default values for integrations.</p> <pre><code>integrations:\n  atlassian:\n    jira:\n      enabled: true\n      auto_create_issue: true\n      auto_create_issue_type: Task\n      project: KAN\n      issue_types: ['Task', 'Epic']\n      labels:\n        - incident-management\n      status_mapping:\n        - incident_status: Investigating\n          jira_status: Open\n        - incident_status: Identified\n          jira_status: In Progress\n        - incident_status: Monitoring\n          jira_status: In Review\n        - incident_status: Resolved\n          jira_status: Done\n</code></pre>"},{"location":"integrations/#opsgenie","title":"Opsgenie","text":"<p>You can integrate with Opsgenie to create incidents. To start, you'll need an API integration key for your Opsgenie account. You should also have at least one Opsgenie team created to alert for pages.</p> <p>Warning</p> <p>If you're using Opsgenie's Free or Essentials plan or if you\u2019re using Opsgenie with Jira Service Management's Standard plan, you can add this integration from your team dashboard only. The Integrations page under Settings is not available in your plan. </p> <p>In short, you can only create an API integration for a team if on one of these plans. The drop down when creating an alert will only ever show this team as the recipient. If you wish to use more than one team, you will need to upgrade to a compatible plan and provide an organization-wide key.</p> <p>Warning</p> <p>Note that keys attached to an API integrations created for a specific team are not the same as the API key created for an Opsgenie organization within global settings. While you can create this key, it will not work to provide functionality for creating alerts.</p> <p>For additional information, review this article.</p> <p>Provide the following variables depending on your setup:</p> <ul> <li><code>ATLASSIAN_OPSGENIE_API_KEY</code> - Required if creating an org-wide API integration.</li> <li><code>ATLASSIAN_OPSGENIE_API_TEAM_INTEGRATION_KEY</code> - Required if if using free or essentials tier plans.</li> </ul>"},{"location":"integrations/#configurating-the-opsgenie-integration","title":"Configurating the Opsgenie Integration","text":"<p>In the application's <code>config.yaml</code>, you can adjust <code>opsgenie</code> settings using the <code>integrations</code> section:</p> <p>Warning</p> <p>You must provide all of these values in order for the integration to work. There are no default values for integrations.</p> <pre><code>integrations:\n  atlassian:\n    opsgenie:\n      enabled: true\n      team: oncalls\n</code></pre>"},{"location":"integrations/#statuspage","title":"Statuspage","text":"<p>You can integrate with Statuspage to automatically prompt for Statuspage incident creation for new incidents. You can also update them directly from Slack.</p> <p>Provide the following environment variables:</p> <ul> <li><code>STATUSPAGE_API_KEY</code> - Statuspage API key.</li> <li><code>STATUSPAGE_PAGE_ID</code> - Statuspage page ID.</li> </ul>"},{"location":"integrations/#configurating-the-statuspage-integration","title":"Configurating the Statuspage Integration","text":"<p>In the application's <code>config.yaml</code>, you can adjust <code>statuspage</code> settings using the <code>integrations</code> section:</p> <p>Warning</p> <p>You must provide all of these values in order for the integration to work. There are no default values for integrations.</p> <pre><code>integrations:\n  atlassian:\n    statuspage:\n      enabled: true\n      url: https://status.mydomain.com\n</code></pre> <p>You can optionally add groups under the <code>permissions.groups</code> heading to limit who can create and manage Statuspage incidents from Slack. Anyone not in one of these groups will get an ephemeral message indicating they do not have the required permissions.</p>"},{"location":"integrations/#using-the-statuspage-integration","title":"Using the Statuspage Integration","text":"<p>With the integration enabled, a new incident will prompt for the creation of a Statuspage incident:</p> <p></p> <p>Fill out the required information to create a Statuspage incident:</p> <p></p> <p></p> <p>You can use the buttons to provide updates. The message will be updated indicating updates applied to the ongoing incident:</p> <p></p> <p></p>"},{"location":"integrations/#pagerduty","title":"PagerDuty","text":"<p>You can integrate with PagerDuty to issue pages to teams. Set the following environment variables:</p> <ul> <li><code>PAGERDUTY_API_TOKEN</code></li> <li><code>PAGERDUTY_API_USERNAME</code></li> </ul> <p>In the application's <code>config.yaml</code>, you can set the PagerDuty integration to active by setting <code>enabled</code> to <code>true</code>:</p> <pre><code>pagerduty:\n  enabled: true\n</code></pre> <p>You are then able to use the bot's pager options. These are introduced at various points through the incident management process.</p>"},{"location":"integrations/#zoom","title":"Zoom","text":"<p>The bot can automatically create a Zoom meeting for each new incident.</p> <p>If you want to automatically create an instant Zoom meeting for each incident, use the following steps to create a Zoom app and enable the integration:</p> <ol> <li>Visit https://marketplace.zoom.us/develop/create.</li> <li>Create a Server-to-Server OAuth app.</li> <li>Fill out the required generic information.</li> <li>Add scope for View and manage all user meetings.</li> <li>Activate app.</li> <li>Add account ID, client ID, and client secret to env vars below.</li> </ol> <p>Warning</p> <p>The account ID can be viewed on the app's page in the Zoom Marketplace developer app after it has been activated.</p> <p>Provide the following environment variables:</p> <ul> <li><code>ZOOM_ACCOUNT_ID</code> - Account ID from the step above.</li> <li><code>ZOOM_CLIENT_ID</code> - The OAuth app client ID from the step above.</li> <li><code>ZOOM_CLIENT_SECRET</code> - The OAuth app client secret from the step above.</li> </ul>"},{"location":"integrations/#configurating-the-zoom-integration","title":"Configurating the Zoom Integration","text":"<p>In the application's <code>config.yaml</code>, you can adjust <code>zoom</code> settings using the <code>integrations</code> section:</p> <p>Warning</p> <p>You must provide all of these values in order for the integration to work. There are no default values for integrations.</p> <pre><code>zoom:\n  enabled: true\n  auto_creating_meeting: true\n</code></pre>"},{"location":"ui/","title":"Web Interface","text":""},{"location":"ui/#prerequisites","title":"Prerequisites","text":""},{"location":"ui/#api","title":"API","text":"<p>Additional API routes are disabled by default. This flag only needs to be set to <code>true</code> if using the web interface.</p> <p>Note that the API exposes a health check route.</p> <p>Note</p> <p>The web interface is optional and is not required to use the application.</p> <pre><code>api:\n  enabled: true\n</code></pre> <p>With the API enabled, routes will be made available via <code>/api/v1</code>.</p> <p>Warning</p> <p>API routes are only meant to serve the web interface. As such, they are secured using JWT and will not work without first running through the setup guide for the web interface.</p>"},{"location":"ui/#authentication","title":"Authentication","text":"<p>Warning</p> <p>The default username and password for the web interface are set to <code>admin@example.com</code>:<code>changethis</code>. It is strongly recommended you change these variables before exposing the API.</p> <p>Set the environment variables <code>FIRST_SUPERUSER</code> and <code>FIRST_SUPERUSER_PASSWORD</code> to unique values before running the application the first time.</p> <pre><code># incidentbot/configuration/settings.py\nFIRST_SUPERUSER: str = \"admin@example.com\"\nFIRST_SUPERUSER_PASSWORD: str = \"changethis\"\n</code></pre> <p>Consult the API documentation for additional settings related to it.</p>"},{"location":"ui/#running-the-web-interface","title":"Running the Web Interface","text":""},{"location":"ui/#building-the-docker-image","title":"Building the Docker Image","text":"<p>There is a separate repository for the web interface located here.</p> <p>Since the client application must be built with the API URL as an argument, you will need to build and host the image for the web interface on your own.</p> <p>The easiest way to do this is to use the base image which already contains the application logic:</p> <pre><code>FROM eb129/incidentbot-console:v0.1.0 AS build\nWORKDIR /app\nARG VITE_API_URL=${VITE_API_URL}\nRUN npm run build\nFROM nginx:1\nCOPY --from=build /app/dist/ /usr/share/nginx/html\nCOPY ./nginx.conf /etc/nginx/conf.d/default.conf\nCOPY ./nginx-backend-not-found.conf /etc/nginx/extra-conf.d/backend-not-found.conf\n</code></pre> <p>You will need to provide the content of nginx.conf and nginx-backend-not-found.conf in the build directory.</p>"},{"location":"ui/#deploying-via-helm","title":"Deploying via Helm","text":"<p>You can get started quickly by using the Helm chart:</p> <pre><code>helm repo add incidentbot https://charts.incidentbot.io\nhelm repo update\n</code></pre> <p>Create a <code>values.yaml</code> file. We'll call this one <code>incidentbot-console-values.yaml</code>:</p> <pre><code># Reference the image built earlier.\nimage:\n  repository: myrepo/incidentbot-console\n  tag: mytag\ningress:\n  enabled: true\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    cert-manager.io/cluster-issuer: letsencrypt-prod\n  hosts:\n    - host: incidentbot-console.mydomain.com\n      paths:\n        - path: /\n          pathType: ImplementationSpecific\n  tls:\n    - secretName: incidentbot-tls\n      hosts:\n        - incidentbot-console.mydomain.com\n</code></pre> <p>Install the chart:</p> <pre><code>VERSION=$(helm search repo incidentbot --output=json | jq '.[1].version' | tr -d '\"')\nhelm install incidentbot/incidentbot-console --version $VERSION --values incidentbot-console-values.yaml --namespace incidentbot\n</code></pre>"},{"location":"usage/","title":"Usage Guide","text":""},{"location":"usage/#interacting","title":"Interacting","text":"<p>The main method of interacting with the bot is via its slash command - <code>/incidentbot</code> by default.</p> <p>Type <code>/incidentbot</code> (or whatever you've set the slash command to) in any channcel to get a prompt:</p> <p></p> <p>Once you hit <code>return</code>, you'll be presented with the core prompt:</p> <p></p> <p>From here you can declare an incident, list all incidents, manage incident timelines, or send out incident updates.</p>"},{"location":"usage/#running-incidents","title":"Running Incidents","text":""},{"location":"usage/#starting-an-incident","title":"Starting an Incident","text":"<p>Use the <code>Declare Incident</code> option via the bot prompt and you'll be issued the modal to declare an incident:</p> <p></p> <p>Provide information as-needed and hit <code>Start</code> to kick off the incident management process for this new incident.</p>"},{"location":"usage/#managing-an-incident","title":"Managing an Incident","text":"<p>The digest channel shows the status of any incident:</p> <p></p> <p>When an incident has a meeting link:</p> <p></p> <p>When an incident is resolved:</p> <p></p> <p>From here, anyone can see the status of any incident at any time and join it if they choose to.</p> <p>All new incidents receive a welcome message with context on things to do at the start of an incident:</p> <p></p> <p>If the Jira integration is enabled, you'll see an option to create a Jira issue:</p> <p></p> <p>From here, one can pick up a role by clicking on the role buttons:</p> <p></p> <p>The channel will be notified about the role being assigned. The person accepting the role will be sent information on what the role entails. These messages are customizable.</p> <p>At any time, you can use the <code>Describe</code> function to output a message that describes all current incident parameters, including assigned roles:</p> <p></p>"},{"location":"usage/#interacting-directly","title":"Interacting Directly","text":"<p>The bot contains a subcommand called <code>this</code>. Running <code>/incidentbot this</code> will provide a prompt to interact with an incident:</p> <p>Warning</p> <p>The <code>this</code> subcommand only works within an incident channel.</p> <p></p> <p>From here, you can:</p> <p>Set severity:</p> <p></p> <p>Set status:</p> <p></p> <p>List responders:</p> <p></p> <p>Note</p> <p>With the <code>List Responders</code> option, you have the option to leave a role if you're currently assigned to it. You cannot remove others.</p> <p>Get help:</p> <p></p> <p>...and various other features depending on what is enabled.</p>"},{"location":"usage/#app-home","title":"App Home","text":"<p>You can click on Incident Bot in the Slack sidebar to go to the app home:</p> <p></p> <p>From here, you can declare an incident, create a maintenance window (if enabled), see open incidents, and see any maintenance windows.</p>"}]}